sort
    % We need to be able to tell if we are now executing when clauses or if we
    % are accepting commands.
    Phase = struct WhenPhase ?isWhenPhase | ActionPhase ?isActPhase;

    % Every process should be assigned a unique identifier.
    Id = Nat;
    IdList = List(Id);
    Child = Id;
    Children = List(Id);
    
    % Static configuration of a process
    Config = struct configuration(self_id: Id,           % Id of this process
                                  parent: Id,         % Id of parent
                                  children: Children, % Ids of children
                                  cc: Class -> Children, % Mapping of FSM class to list of children.
                                  rsc: Bool           % Allow random state changes
                                 );
                                 
    % Whenever we want to send a command to one or more children, we copy this
    % command for every child recipient and store it in a CommandQueue.
    ChildCommand = struct childcommand(child_id:Id, command:Command);
    CommandQueue = List(ChildCommand);


Class = struct RPC_Chamber_CLASS_BM ? isRPC_Chamber_CLASS_BM | RPC_HV_CLASS_BM ? isRPC_HV_CLASS_BM | RPC_LV_CLASS_BM ? isRPC_LV_CLASS_BM | RPC_T_CLASS_BM ? isRPC_T_CLASS_BM | RPC_Wheel_CLASS ? isRPC_Wheel_CLASS | RPC_Sector_CLASS ? isRPC_Sector_CLASS | RPC_LBBLV_CLASS ? isRPC_LBBLV_CLASS | RPC_Chamber_CLASS ? isRPC_Chamber_CLASS;
   State = struct S_FSM_UNINITIALIZED ? isS_FSM_UNINITIALIZED | S_OFF ? isS_OFF | S_ERROR ? isS_ERROR | S_TRIPPED ? isS_TRIPPED | S_RAMPING ? isS_RAMPING | S_RAMPING_DOWN ? isS_RAMPING_DOWN | S_RAMPING_UP ? isS_RAMPING_UP | S_STANDBY ? isS_STANDBY | S_ON ? isS_ON | S_OK ? isS_OK;
   Command = struct C_STANDBY ? isC_STANDBY | C_ON ? isC_ON | C_OFF ? isC_OFF;
act
    % Commands are sent between a sending process X and a receiving process Y.
    % Examples:
    %     rc(X,Y,cmd): receive command sent from X to Y; use in process Y.
    %     sc(X,Y,cmd): send command from X to Y; use in process X.
    %     cc(X,Y,cmd): communication between r(X,Y,cmd) and s(X,Y,cmd).
    rc,sc,cc: Id # Id # Command;

    % Children will respond to a command by (eventually) sending their new state.
    % The use of the following actions is analogous to the rc/sc/cc commands.
    rs,ss,cs: Id # Id # State;

    % Action identifying a move to a new State.
    move_state: Id # State;

    % Action identifing a move to a new Phase.
    move_phase: Id # Phase;

    % Action triggered when a command is ignored.
    ignored_command: Id # Command;

    % Action triggered when we queue one or more messages.
    queue_messages: Id;

    % Action triggered when we enter a then clause.
    enter_then_clause: Id;

    % Action triggered when we enter an else clause.
    enter_else_clause: Id;

    % Action triggered when we skip over a then block.
    skip_then_clause: Id;

    % Action triggered when we start initializing.
    start_initialization: Id;

    % Action triggered when we end initializing.
    end_initialization: Id;

    % Action triggered when we execute an action without statements.
    noop_statement: Id;

map
    % Returns whether or not a Child is in a certain State.
    in_state: Child # (Child -> State) # State -> Bool;

    % Returns whether or not there is a Child with Id in Children.
    is_child: Id # Children -> Bool;

    % Given a Command and a Children list, create a new CommandQueue with an
    % (id(Child), Command) tuple for every Child in Children.
    send_command: Command # Children -> CommandQueue;

    % Remove the first occurrence of an Id from a list of Ids.
    remove: Id # IdList -> IdList;

    % Insert element into list if it is not yet part of the list. Keep list
    % sorted.
    insertUnique: Children # Child -> Children;
    removeFirst: Children # Child -> Children;

    % Map all children to state uninitialized
    allChildrenUninitialized: Child -> State;

    % Map all PTypes to the empty list of children.
    allClassesEmpty: Class -> Children;

var
    cq: CommandQueue;
    chs,chs_accu: Children;
    ch, ch1, ch2: Child;
    id,id1: Id;
    ids: IdList;
    s,s1: State;
    sl: List(State);
    t,t1: Class;
    cmd: Command;
    b, b1, b2: Bool;
    pc, pc1: Int;
    children_state: Child -> State;

eqn
    % See the map section for the intended behaviour of the functions.
    in_state(ch, children_state,s) = children_state(ch) == s;

    is_child(id, chs) = id in chs;

    send_command(cmd, []) = [];
    send_command(cmd, id |> chs) =
        childcommand(id,cmd) |> send_command(cmd,chs);

    remove(id, []) = [];
    remove(id, id1 |> ids) =
      if (id == id1,
        ids,
        id1 |> remove(id, ids));

    insertUnique([], ch1) = [ch1];
    (ch2 > ch1) -> insertUnique(ch1 |> chs, ch2) = ch1 |> insertUnique(chs, ch2);
    (ch2 < ch1) -> insertUnique(ch1 |> chs, ch2) = ch2 |> ch1 |> chs;
    insertUnique(ch1 |> chs, ch1) = chs;

    removeFirst([], ch1) = [];
    removeFirst(ch1 |> chs, ch1) = chs;
    (ch1 != ch2) -> removeFirst(ch1 |> chs, ch2) = ch1 |> removeFirst(chs, ch2);

    allChildrenUninitialized(ch) = S_FSM_UNINITIALIZED;
    allClassesEmpty(t) = [];


%% This file implements the three-valued logic that is used in the
%% interpretation of when clauses. It is based on the description by Boda Franek
%% titled "Condition processing", dated May 2011.

sort ThreeValuedLogic = struct TRUE | FALSE | GHOST;

map % Standard logic operators, extended to three values
    or, and: ThreeValuedLogic # ThreeValuedLogic -> ThreeValuedLogic;
    not: ThreeValuedLogic -> ThreeValuedLogic;
    % Convert a three valued logic value to Boolean
    bool: ThreeValuedLogic -> Bool;
    % Convert a Boolean to a three valued logic value
    threeval: Bool -> ThreeValuedLogic;

var x: ThreeValuedLogic;
eqn (x != GHOST) -> or(x, GHOST) = x;
    (x != GHOST) -> or(GHOST, x) = x;
    (x != GHOST) -> or(TRUE, x) = TRUE;
    (x != GHOST) -> or(x, TRUE) = TRUE;
    (x != GHOST) -> or(FALSE, x) = x;
    (x != GHOST) -> or(x, FALSE) = x;
    or(x, x) = x;

    (x != GHOST) -> and(x, GHOST) = x;
    (x != GHOST) -> and(GHOST, x) = x;
    (x != GHOST) -> and(TRUE, x) = x;
    (x != GHOST) -> and(x, TRUE) = x;
    (x != GHOST) -> and(FALSE, x) = FALSE;
    (x != GHOST) -> and(x, FALSE) = FALSE;
    and(x, x) = x;
    
    not(GHOST) = GHOST;
    not(TRUE) = FALSE;
    not(FALSE) = TRUE;

    bool(TRUE) = true;
    bool(FALSE) = false;
    bool(GHOST) = false;
    
    threeval(true) = TRUE;
    threeval(false) = FALSE;
    
map % Check whether a child is in any of the states in a list.
    in_any_of_states: Child # (Child -> State) # List(State) -> ThreeValuedLogic;
    % Check whether a child is not in any of the states in a list.
    not_in_any_of_states: Child # (Child -> State) # List(State) -> ThreeValuedLogic;
    
    % Check whether all children are in any of the states in a list.
    all_in_state: Children # (Child -> State) # List(State) -> ThreeValuedLogic;
    % Check whether any of the children is in any of the states in a list.
    any_in_state: Children # (Child -> State) # List(State) -> ThreeValuedLogic;
    
    % Check whether all children are not in any of the states in a list.
    all_not_in_state: Children # (Child -> State) # List(State) -> ThreeValuedLogic;
    % Check whether any of the children in not in any of the states in a list.
    any_not_in_state: Children # (Child -> State) # List(State) -> ThreeValuedLogic;

var ch: Child;
    chs: Children;
    s: State;
    sl: List(State);
    cs: Child -> State;
eqn in_any_of_states(ch,cs, []) = FALSE;
    in_any_of_states(ch,cs, s|>sl) = or(threeval(cs(ch) == s),
                                        in_any_of_states(ch, cs, sl));

    all_in_state([], cs, sl) = GHOST;
    all_in_state(ch |> chs, cs, sl) = and(in_any_of_states(ch, cs, sl),
                                          all_in_state(chs, cs, sl));
                                          
    any_in_state([], cs, sl) = GHOST;
    any_in_state(ch |> chs, cs, sl) = or(in_any_of_states(ch, cs, sl),
                                         any_in_state(chs, cs, sl));
    
    all_not_in_state([], cs, sl) = GHOST;
    all_not_in_state(ch |> chs, cs, sl) = and(not(in_any_of_states(ch, cs, sl)),
                                              all_not_in_state(chs, cs, sl));
                                              
    any_not_in_state([], cs, sl) = GHOST;
    any_not_in_state(ch |> chs, cs, sl) = or(not(in_any_of_states(ch, cs, sl)),
                                             any_not_in_state(chs, cs, sl));



proc grandParent(self: Id, chs: Children) = 
		% Issue a C_STANDBY command.
		sc(self,head(chs),C_STANDBY).
		sum s:State.(rs(head(chs),self,s)). 
		grandParent(self, tail(chs) <| head(chs) ) + 

		% Issue a C_OFF command.
		sc(self,head(chs),C_OFF).
		sum s:State.(rs(head(chs),self,s)). 
		grandParent(self, tail(chs) <| head(chs) ) + 

		% Issue a C_ON command.
		sc(self,head(chs),C_ON).
		sum s:State.(rs(head(chs),self,s)). 
		grandParent(self, tail(chs) <| head(chs) ) + 

		% Accept notifications.
        sum id:Id, s:State.(rs(id,self,s)).
        grandParent(self, chs)
	;

proc RPC_Wheel_CLASS(config: Config, s: State, cs: Child -> State, busy: Children, phase: Phase, cq: CommandQueue, pc: Int) =
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_OFF(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_ERROR]))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Wheel_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_RAMPING]))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Wheel_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_STANDBY]))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Wheel_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Wheel_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and(((all_not_in_state(children(config), cs, [S_OFF]))), (any_in_state(children(config), cs, [S_STANDBY]))))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Wheel_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Wheel_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_STANDBY(c) -> RPC_Wheel_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Wheel_CLASS(pc = 2) <> (
           (isC_ON(c) -> RPC_Wheel_CLASS(pc = 3) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Wheel_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_STANDBY, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_STANDBY(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_ERROR]))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Wheel_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_RAMPING]))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Wheel_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Wheel_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_OFF]))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Wheel_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Wheel_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_ON(c) -> RPC_Wheel_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Wheel_CLASS(pc = 2) <> (
           (isC_STANDBY(c) -> RPC_Wheel_CLASS(pc = 3) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Wheel_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_STANDBY, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_ON(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_ERROR]))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Wheel_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_RAMPING]))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Wheel_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_OFF]))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Wheel_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_STANDBY]))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Wheel_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Wheel_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_STANDBY(c) -> RPC_Wheel_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Wheel_CLASS(pc = 2) <> (
           (isC_ON(c) -> RPC_Wheel_CLASS(pc = 3) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Wheel_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_STANDBY, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_ERROR(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(and((any_in_state(children(config), cs, [S_RAMPING])), ((all_not_in_state(children(config), cs, [S_ERROR])))))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Wheel_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and((any_in_state(children(config), cs, [S_OFF])), ((all_not_in_state(children(config), cs, [S_ERROR])))))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Wheel_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Wheel_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and((any_in_state(children(config), cs, [S_STANDBY])), ((all_not_in_state(children(config), cs, [S_ERROR])))))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Wheel_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Wheel_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_ON(c) -> RPC_Wheel_CLASS(pc = 1) <> (
           (isC_STANDBY(c) -> RPC_Wheel_CLASS(pc = 2) <> (
           (isC_OFF(c) -> RPC_Wheel_CLASS(pc = 3) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Wheel_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_STANDBY, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_RAMPING(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_ERROR]))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Wheel_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Wheel_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_STANDBY]))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Wheel_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and(((all_not_in_state(children(config), cs, [S_RAMPING]))), (any_in_state(children(config), cs, [S_OFF]))))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Wheel_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and(((all_not_in_state(children(config), cs, [S_RAMPING]))), (any_in_state(children(config), cs, [S_STANDBY]))))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Wheel_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Wheel_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_STANDBY(c) -> RPC_Wheel_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Wheel_CLASS(pc = 2) <> (
           (isC_ON(c) -> RPC_Wheel_CLASS(pc = 3) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Wheel_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_STANDBY, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Wheel_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % BEGIN GENERIC CLAUSES (shared by all states)
    % Whenever we are not sending a command to the children, a child may
    % spontaneously change its state due to a hardware event and send its
    % state upward. Such state-change messages are called notifications.

    % Notifications can occur in the following cases:
    %  (1) While in the action phase:
    %  (1.a) We have not received a command yet in this action phase.
    %  (1.b) We are executing an action, or we finished executing an action but still have to send
    %        some commands.

    % Note that this implies that we never receive notifications during the execution of the when phase (i) and
    % we never receive notifcations directly after we finish sending the last command after executing an action (ii).
    % The rationale behind this is as follows:
    %  (i)  The execution of the when clauses is a noninteractive process: the system decides what the
    %       new state is, based only on *local* information. Therefore, this process finishes almost instantly.
    %       In the real system, notifications which happen to arrive during the when phase would be queued, but
    %       we don't queue messages in our model. It is unlikely that any important behaviour is missed
    %       due to this design decision.
    %  (ii) After sending the last command, the model can move into the when phase. Moving to a new state
    %       before handling this notification will almost certainly be closer to the real behaviour of the
    %       system. We therefore disallow notifications at this point.

    % (1.a) We have initialized and we have not yet received a command in this action phase.
    % We now accept notifications.
    sum id:Id.(sum s1:State.(((isActPhase(phase)) && (is_child(id, children(config))) &&
                             (pc == 0)) ->
       rs(id, self_id(config), s1).
       move_phase(self_id(config), WhenPhase).
       RPC_Wheel_CLASS(cs = cs[id -> s1], busy = removeFirst(busy, id), phase = WhenPhase, cq = [], pc = 0)))
    +

    % (1.b) We are in the middle of executing an action, or we finished executing and still have to send some
    % commands. We accept notifications, but we don't move to
    % the when phase, since we still must execute one or more statements. These semantics are valid
    % assuming a child does not send more than one notifications during the execution of the same
    % actions.
    sum id:Id.(sum s1:State.(((isActPhase(phase)) && (is_child(id, children(config))) &&
           ((pc > 0) ||
            ((pc == -1) && (cq != [])))) ->
       rs(id, self_id(config), s1).
       RPC_Wheel_CLASS(cs = cs[id -> s1], busy = removeFirst(busy, id)))) +


    % Clause to send commands added by actions after the initialization phase. Note that
    % we don't keep track of the children which have not yet responded. Recepients are only
    % marked busy and not added to the nrf list.
    ((isActPhase(phase)) && (cq != [])) ->
        sc(self_id(config), child_id(head(cq)), command(head(cq))).
            RPC_Wheel_CLASS(busy = insertUnique(busy, child_id(head(cq))),
                          cq = tail(cq)) +

    % Go to the when phase whenever all children are initialized, we executed an action
    % and there are no pending messages.
    ((isActPhase(phase)) && (cq == []) && (pc == -1)) ->
        move_phase(self_id(config), WhenPhase).
        RPC_Wheel_CLASS(phase = WhenPhase, cq = [], pc = 0)

    % END GENERIC CLAUSES
    ); proc RPC_Sector_CLASS(config: Config, s: State, cs: Child -> State, busy: Children, phase: Phase, cq: CommandQueue, pc: Int) =
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_OFF(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(or((any_in_state(children(config), cs, [S_ERROR])), (any_in_state(cc(config)(RPC_LBBLV_CLASS), cs, [S_TRIPPED]))))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Sector_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_RAMPING]))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Sector_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_STANDBY]))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Sector_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Sector_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and(((all_not_in_state(children(config), cs, [S_OFF]))), (any_in_state(children(config), cs, [S_STANDBY]))))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Sector_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Sector_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_STANDBY(c) -> RPC_Sector_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Sector_CLASS(pc = 3) <> (
           (isC_ON(c) -> RPC_Sector_CLASS(pc = 4) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Sector_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_STANDBY, children(config)), pc = 2)))
    % END STATEMENT DO
    ) +
     (
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, cc(config)(RPC_LBBLV_CLASS)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_OFF(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 4) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_STANDBY(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(or((any_in_state(children(config), cs, [S_ERROR])), (any_in_state(cc(config)(RPC_LBBLV_CLASS), cs, [S_TRIPPED]))))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Sector_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_RAMPING]))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Sector_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Sector_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_OFF]))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Sector_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Sector_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_ON(c) -> RPC_Sector_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Sector_CLASS(pc = 2) <> (
           (isC_STANDBY(c) -> RPC_Sector_CLASS(pc = 3) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Sector_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_STANDBY(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_STANDBY, children(config)), pc = 4)))
    % END STATEMENT DO
    ) +
     (
    % BEGIN STATEMENT DO
    ((pc == 4) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, cc(config)(RPC_LBBLV_CLASS)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_ON(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(or((any_in_state(children(config), cs, [S_ERROR])), (any_in_state(cc(config)(RPC_LBBLV_CLASS), cs, [S_TRIPPED]))))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Sector_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_RAMPING]))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Sector_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_OFF]))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Sector_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(any_in_state(children(config), cs, [S_STANDBY]))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Sector_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Sector_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_STANDBY(c) -> RPC_Sector_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Sector_CLASS(pc = 3) <> (
           (isC_ON(c) -> RPC_Sector_CLASS(pc = 4) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Sector_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_STANDBY, children(config)), pc = 2)))
    % END STATEMENT DO
    ) +
     (
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, cc(config)(RPC_LBBLV_CLASS)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ON(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 4) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_ERROR(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(and((any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_RAMPING])), ((all_not_in_state(children(config), cs, [S_ERROR, S_TRIPPED])))))) ->
    ss(self_id(config), parent(config), S_RAMPING).
    move_state(self_id(config), S_RAMPING).
    RPC_Sector_CLASS(s = S_RAMPING) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and((any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_OFF])), ((all_not_in_state(children(config), cs, [S_ERROR, S_TRIPPED])))))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Sector_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Sector_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and((any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_STANDBY])), ((all_not_in_state(children(config), cs, [S_ERROR, S_TRIPPED])))))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Sector_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Sector_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_ON(c) -> RPC_Sector_CLASS(pc = 1) <> (
           (isC_STANDBY(c) -> RPC_Sector_CLASS(pc = 2) <> (
           (isC_OFF(c) -> RPC_Sector_CLASS(pc = 4) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Sector_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_STANDBY, children(config)), pc = 3)))
    % END STATEMENT DO
    ) +
     (
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, cc(config)(RPC_LBBLV_CLASS)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_ERROR(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 4) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % ===========
    % BEGIN STATE

    % ------------------
    % BEGIN WHEN CLAUSES
    (
      ((isS_RAMPING(s)) && (isWhenPhase(phase))) ->
      (
    % BEGIN WHEN
    (bool(or((any_in_state(children(config), cs, [S_ERROR])), (any_in_state(cc(config)(RPC_LBBLV_CLASS), cs, [S_TRIPPED]))))) ->
    ss(self_id(config), parent(config), S_ERROR).
    move_state(self_id(config), S_ERROR).
    RPC_Sector_CLASS(s = S_ERROR) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and((any_in_state(children(config), cs, [S_OFF])), ((all_not_in_state(children(config), cs, [S_RAMPING])))))) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Sector_CLASS(s = S_OFF) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_STANDBY]))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Sector_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(all_in_state(children(config), cs, [S_ON]))) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Sector_CLASS(s = S_ON) <>
    % END WHEN
    ((
    % BEGIN WHEN
    (bool(and(((all_not_in_state(children(config), cs, [S_RAMPING]))), (any_in_state(cc(config)(RPC_Chamber_CLASS), cs, [S_STANDBY]))))) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Sector_CLASS(s = S_STANDBY) <>
    % END WHEN
    ((
    % BEGIN WHEN FALLTHROUGH
    ss(self_id(config), parent(config), s).
    move_phase(self_id(config), ActionPhase).
    RPC_Sector_CLASS(phase = ActionPhase, cq = [], pc = 0)
    % END WHEN FALLTHROUGH
    ))
    ))
    ))
    ))
    ))
    )
    ) +

    % END WHEN CLAUSES
    % ----------------

    % --------------------
    % BEGIN ACTION CLAUSES

    % Note:
    %% These were the old rules (before initial was removed from ActPhaseArgs):
    %%  initial(aArgs) && pc(aArgs) == 0                        => no command received yet
    %%  initial(aArgs) && pc(aArgs) != 0                        => command received, executing action clause
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) != []     => action clause executed, but still must send commands
    %% !initial(aArgs) && pc(aArgs) == 0 && cq(aArgs) == []     => action clause executed

    %% These are the new rules:
    % pc(aArgs) == 0                        => no command received yet
    % pc(aArgs) > 0                         => command received, executing action clause
    % pc(aArgs) == -1 && cq(aArgs) != []    => action clause executed, but still must send commands
    % pc(aArgs) == -1 && cq(aArgs) == []    => action clause executed

    %% Since the FSM language allows for an arbitrary amount of statements and an arbitrary amount of
    %% (nested) if-statements, we cannot simply do a sequential translation. It is for this reason that
    %% we use a label to identify the translation of every statement. After executing a statement,
    %% a program counter is set to the label of the statement which should be executed next. There are
    %% two special cases here:
    %%   * Label 0, the clause selector. In the action phase, we always first have pc == 0. When we receive
    %%     a command, the clause selector determines the label of the first statement of the action clause 
    %%     that should handle the command. The program count is then set to this label.
    %%   * Label -1, end of action. After executing an action, the program counter is set to -1 to signify
    %%     that we should now empty the sendqueue and move to the when phase.

    %% Examples can be found in the translation function of the if-statement.

    % BEGIN CLAUSE SELECTOR

    (
    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [] && pc == 0)) ->
        sum c:Command.(
           rc(parent(config), self_id(config), c).
           (isC_STANDBY(c) -> RPC_Sector_CLASS(pc = 1) <> (
           (isC_OFF(c) -> RPC_Sector_CLASS(pc = 3) <> (
           (isC_ON(c) -> RPC_Sector_CLASS(pc = 4) <> (
           ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Sector_CLASS(pc = -1)))))))
    )) +
    % END CLAUSE SELECTOR

    (
    % BEGIN ACTION

    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 1) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_STANDBY, children(config)), pc = 2)))
    % END STATEMENT DO
    ) +
     (
    % BEGIN STATEMENT DO
    ((pc == 2) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, cc(config)(RPC_LBBLV_CLASS)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 3) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_OFF, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    ((
    % BEGIN ACTION

    (((isS_RAMPING(s)) && (isActPhase(phase)) && (cq == [])) ->
    ((
    % BEGIN STATEMENT DO
    ((pc == 4) ->
         queue_messages(self_id(config)).
         (RPC_Sector_CLASS(cq = send_command(C_ON, children(config)), pc = -1)))
    % END STATEMENT DO
    ))) +

    % END ACTION

    (delta))))))
    )

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    ) +
    (
    % BEGIN GENERIC CLAUSES (shared by all states)
    % Whenever we are not sending a command to the children, a child may
    % spontaneously change its state due to a hardware event and send its
    % state upward. Such state-change messages are called notifications.

    % Notifications can occur in the following cases:
    %  (1) While in the action phase:
    %  (1.a) We have not received a command yet in this action phase.
    %  (1.b) We are executing an action, or we finished executing an action but still have to send
    %        some commands.

    % Note that this implies that we never receive notifications during the execution of the when phase (i) and
    % we never receive notifcations directly after we finish sending the last command after executing an action (ii).
    % The rationale behind this is as follows:
    %  (i)  The execution of the when clauses is a noninteractive process: the system decides what the
    %       new state is, based only on *local* information. Therefore, this process finishes almost instantly.
    %       In the real system, notifications which happen to arrive during the when phase would be queued, but
    %       we don't queue messages in our model. It is unlikely that any important behaviour is missed
    %       due to this design decision.
    %  (ii) After sending the last command, the model can move into the when phase. Moving to a new state
    %       before handling this notification will almost certainly be closer to the real behaviour of the
    %       system. We therefore disallow notifications at this point.

    % (1.a) We have initialized and we have not yet received a command in this action phase.
    % We now accept notifications.
    sum id:Id.(sum s1:State.(((isActPhase(phase)) && (is_child(id, children(config))) &&
                             (pc == 0)) ->
       rs(id, self_id(config), s1).
       move_phase(self_id(config), WhenPhase).
       RPC_Sector_CLASS(cs = cs[id -> s1], busy = removeFirst(busy, id), phase = WhenPhase, cq = [], pc = 0)))
    +

    % (1.b) We are in the middle of executing an action, or we finished executing and still have to send some
    % commands. We accept notifications, but we don't move to
    % the when phase, since we still must execute one or more statements. These semantics are valid
    % assuming a child does not send more than one notifications during the execution of the same
    % actions.
    sum id:Id.(sum s1:State.(((isActPhase(phase)) && (is_child(id, children(config))) &&
           ((pc > 0) ||
            ((pc == -1) && (cq != [])))) ->
       rs(id, self_id(config), s1).
       RPC_Sector_CLASS(cs = cs[id -> s1], busy = removeFirst(busy, id)))) +


    % Clause to send commands added by actions after the initialization phase. Note that
    % we don't keep track of the children which have not yet responded. Recepients are only
    % marked busy and not added to the nrf list.
    ((isActPhase(phase)) && (cq != [])) ->
        sc(self_id(config), child_id(head(cq)), command(head(cq))).
            RPC_Sector_CLASS(busy = insertUnique(busy, child_id(head(cq))),
                          cq = tail(cq)) +

    % Go to the when phase whenever all children are initialized, we executed an action
    % and there are no pending messages.
    ((isActPhase(phase)) && (cq == []) && (pc == -1)) ->
        move_phase(self_id(config), WhenPhase).
        RPC_Sector_CLASS(phase = WhenPhase, cq = [], pc = 0)

    % END GENERIC CLAUSES
    );

proc RPC_Chamber_CLASS_BM(config: Config, s: State, cs: Child -> State, busy: Children, phase: Phase, cq: CommandQueue, pc: Int) =
    (
    % ===========
    % BEGIN STATE

    %% If random state changes are enabled, then we can move to any state
    %% in any move_to referer. Upon receiving an action, move immediately
    %% to the corresponding state if such a state exists; otherwise, ignore
    %% the command.

    %% For example, if we have the following situation:

    %% state: ON
    %% state: OFF
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to ERROR
    %%    when ( $ANY$FwCHILDREN in_state ON ) move_to ON
    %%    action: ON
    %%        do ON $ALL$FwCHILDREN
    %%    action: STANDBY
    %%        do STANDBY $ALL$FwCHILDREN
    %% state: ERROR
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to OFF

    %% Then this is translated (roughly) to:

    %% (state is ON -> delta) +
    %% (state is OFF ->
    %%   (random state changes are enabled -> move_state ERROR) +
    %%   (random state changes are enabled -> move_state ON) +
    %%   (receive command STANDBY . ignore command STANDBY)) +
    %%   (receive command ON . move_state ON)) +
    %% (state is ERROR) ->
    %%   (random state changes are enabled -> move_state OFF))

    % --------------------------
    % BEGIN RANDOM STATE CHANGES

    (isS_OFF(s) ->
        sum s1: State.((rsc(config) && (isS_ERROR(s1) || isS_TRIPPED(s1) || isS_RAMPING(s1) || isS_RAMPING_DOWN(s1) || isS_RAMPING_UP(s1) || isS_STANDBY(s1) || isS_ON(s1) || isS_OK(s1) || false)) ->
            ss(self_id(config), parent(config), s1).
            move_state(self_id(config), s1).
            RPC_Chamber_CLASS_BM(phase = WhenPhase, cq = [], pc = 0))) +

    % END RANDOM STATE CHANGES
    % ------------------------

    % --------------------
    % BEGIN ACTION CLAUSES

    
    ((isS_OFF(s)) ->
    sum c: Command.
    (
    rc(parent(config), self_id(config), c).
    ((c == C_STANDBY) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Chamber_CLASS_BM(s = S_STANDBY, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_OFF) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Chamber_CLASS_BM(s = S_OFF, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_ON) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Chamber_CLASS_BM(s = S_ON, phase = WhenPhase, cq = [], pc = 0)
    <>
    ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Chamber_CLASS_BM(pc = -1))))
    )
    )
   

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    
    ) +
    (
    % ===========
    % BEGIN STATE

    %% If random state changes are enabled, then we can move to any state
    %% in any move_to referer. Upon receiving an action, move immediately
    %% to the corresponding state if such a state exists; otherwise, ignore
    %% the command.

    %% For example, if we have the following situation:

    %% state: ON
    %% state: OFF
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to ERROR
    %%    when ( $ANY$FwCHILDREN in_state ON ) move_to ON
    %%    action: ON
    %%        do ON $ALL$FwCHILDREN
    %%    action: STANDBY
    %%        do STANDBY $ALL$FwCHILDREN
    %% state: ERROR
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to OFF

    %% Then this is translated (roughly) to:

    %% (state is ON -> delta) +
    %% (state is OFF ->
    %%   (random state changes are enabled -> move_state ERROR) +
    %%   (random state changes are enabled -> move_state ON) +
    %%   (receive command STANDBY . ignore command STANDBY)) +
    %%   (receive command ON . move_state ON)) +
    %% (state is ERROR) ->
    %%   (random state changes are enabled -> move_state OFF))

    % --------------------------
    % BEGIN RANDOM STATE CHANGES

    (isS_STANDBY(s) ->
        sum s1: State.((rsc(config) && (isS_ERROR(s1) || isS_TRIPPED(s1) || isS_RAMPING(s1) || isS_RAMPING_UP(s1) || isS_RAMPING_DOWN(s1) || isS_OFF(s1) || isS_ON(s1) || false)) ->
            ss(self_id(config), parent(config), s1).
            move_state(self_id(config), s1).
            RPC_Chamber_CLASS_BM(phase = WhenPhase, cq = [], pc = 0))) +

    % END RANDOM STATE CHANGES
    % ------------------------

    % --------------------
    % BEGIN ACTION CLAUSES

    
    ((isS_STANDBY(s)) ->
    sum c: Command.
    (
    rc(parent(config), self_id(config), c).
    ((c == C_ON) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Chamber_CLASS_BM(s = S_ON, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_OFF) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Chamber_CLASS_BM(s = S_OFF, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_STANDBY) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Chamber_CLASS_BM(s = S_STANDBY, phase = WhenPhase, cq = [], pc = 0)
    <>
    ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Chamber_CLASS_BM(pc = -1))))
    )
    )
   

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    
    ) +
    (
    % ===========
    % BEGIN STATE

    %% If random state changes are enabled, then we can move to any state
    %% in any move_to referer. Upon receiving an action, move immediately
    %% to the corresponding state if such a state exists; otherwise, ignore
    %% the command.

    %% For example, if we have the following situation:

    %% state: ON
    %% state: OFF
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to ERROR
    %%    when ( $ANY$FwCHILDREN in_state ON ) move_to ON
    %%    action: ON
    %%        do ON $ALL$FwCHILDREN
    %%    action: STANDBY
    %%        do STANDBY $ALL$FwCHILDREN
    %% state: ERROR
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to OFF

    %% Then this is translated (roughly) to:

    %% (state is ON -> delta) +
    %% (state is OFF ->
    %%   (random state changes are enabled -> move_state ERROR) +
    %%   (random state changes are enabled -> move_state ON) +
    %%   (receive command STANDBY . ignore command STANDBY)) +
    %%   (receive command ON . move_state ON)) +
    %% (state is ERROR) ->
    %%   (random state changes are enabled -> move_state OFF))

    % --------------------------
    % BEGIN RANDOM STATE CHANGES

    (isS_ON(s) ->
        sum s1: State.((rsc(config) && (isS_ERROR(s1) || isS_TRIPPED(s1) || isS_RAMPING(s1) || isS_RAMPING_DOWN(s1) || isS_RAMPING_UP(s1) || isS_STANDBY(s1) || isS_ON(s1) || isS_OFF(s1) || false)) ->
            ss(self_id(config), parent(config), s1).
            move_state(self_id(config), s1).
            RPC_Chamber_CLASS_BM(phase = WhenPhase, cq = [], pc = 0))) +

    % END RANDOM STATE CHANGES
    % ------------------------

    % --------------------
    % BEGIN ACTION CLAUSES

    
    ((isS_ON(s)) ->
    sum c: Command.
    (
    rc(parent(config), self_id(config), c).
    ((c == C_STANDBY) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Chamber_CLASS_BM(s = S_STANDBY, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_OFF) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Chamber_CLASS_BM(s = S_OFF, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_ON) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Chamber_CLASS_BM(s = S_ON, phase = WhenPhase, cq = [], pc = 0)
    <>
    ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Chamber_CLASS_BM(pc = -1))))
    )
    )
   

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    
    ) +
    (
    % ===========
    % BEGIN STATE

    %% If random state changes are enabled, then we can move to any state
    %% in any move_to referer. Upon receiving an action, move immediately
    %% to the corresponding state if such a state exists; otherwise, ignore
    %% the command.

    %% For example, if we have the following situation:

    %% state: ON
    %% state: OFF
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to ERROR
    %%    when ( $ANY$FwCHILDREN in_state ON ) move_to ON
    %%    action: ON
    %%        do ON $ALL$FwCHILDREN
    %%    action: STANDBY
    %%        do STANDBY $ALL$FwCHILDREN
    %% state: ERROR
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to OFF

    %% Then this is translated (roughly) to:

    %% (state is ON -> delta) +
    %% (state is OFF ->
    %%   (random state changes are enabled -> move_state ERROR) +
    %%   (random state changes are enabled -> move_state ON) +
    %%   (receive command STANDBY . ignore command STANDBY)) +
    %%   (receive command ON . move_state ON)) +
    %% (state is ERROR) ->
    %%   (random state changes are enabled -> move_state OFF))

    % --------------------------
    % BEGIN RANDOM STATE CHANGES

    (isS_ERROR(s) ->
        sum s1: State.((rsc(config) && (isS_RAMPING(s1) || isS_ERROR(s1) || isS_TRIPPED(s1) || isS_RAMPING_UP(s1) || isS_RAMPING_DOWN(s1) || isS_ON(s1) || isS_STANDBY(s1) || isS_OFF(s1) || false)) ->
            ss(self_id(config), parent(config), s1).
            move_state(self_id(config), s1).
            RPC_Chamber_CLASS_BM(phase = WhenPhase, cq = [], pc = 0))) +

    % END RANDOM STATE CHANGES
    % ------------------------

    % --------------------
    % BEGIN ACTION CLAUSES

    
    ((isS_ERROR(s)) ->
    sum c: Command.
    (
    rc(parent(config), self_id(config), c).
    ((c == C_ON) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Chamber_CLASS_BM(s = S_ON, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_STANDBY) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Chamber_CLASS_BM(s = S_STANDBY, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_OFF) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Chamber_CLASS_BM(s = S_OFF, phase = WhenPhase, cq = [], pc = 0)
    <>
    ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Chamber_CLASS_BM(pc = -1))))
    )
    )
   

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    
    ) +
    (
    % ===========
    % BEGIN STATE

    %% If random state changes are enabled, then we can move to any state
    %% in any move_to referer. Upon receiving an action, move immediately
    %% to the corresponding state if such a state exists; otherwise, ignore
    %% the command.

    %% For example, if we have the following situation:

    %% state: ON
    %% state: OFF
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to ERROR
    %%    when ( $ANY$FwCHILDREN in_state ON ) move_to ON
    %%    action: ON
    %%        do ON $ALL$FwCHILDREN
    %%    action: STANDBY
    %%        do STANDBY $ALL$FwCHILDREN
    %% state: ERROR
    %%    when ( $ANY$FwCHILDREN in_state WARNING ) move_to OFF

    %% Then this is translated (roughly) to:

    %% (state is ON -> delta) +
    %% (state is OFF ->
    %%   (random state changes are enabled -> move_state ERROR) +
    %%   (random state changes are enabled -> move_state ON) +
    %%   (receive command STANDBY . ignore command STANDBY)) +
    %%   (receive command ON . move_state ON)) +
    %% (state is ERROR) ->
    %%   (random state changes are enabled -> move_state OFF))

    % --------------------------
    % BEGIN RANDOM STATE CHANGES

    (isS_RAMPING(s) ->
        sum s1: State.((rsc(config) && (isS_ERROR(s1) || isS_TRIPPED(s1) || isS_STANDBY(s1) || isS_ON(s1) || isS_OFF(s1) || isS_RAMPING_DOWN(s1) || isS_RAMPING_UP(s1) || false)) ->
            ss(self_id(config), parent(config), s1).
            move_state(self_id(config), s1).
            RPC_Chamber_CLASS_BM(phase = WhenPhase, cq = [], pc = 0))) +

    % END RANDOM STATE CHANGES
    % ------------------------

    % --------------------
    % BEGIN ACTION CLAUSES

    
    ((isS_RAMPING(s)) ->
    sum c: Command.
    (
    rc(parent(config), self_id(config), c).
    ((c == C_STANDBY) ->
    ss(self_id(config), parent(config), S_STANDBY).
    move_state(self_id(config), S_STANDBY).
    RPC_Chamber_CLASS_BM(s = S_STANDBY, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_OFF) ->
    ss(self_id(config), parent(config), S_OFF).
    move_state(self_id(config), S_OFF).
    RPC_Chamber_CLASS_BM(s = S_OFF, phase = WhenPhase, cq = [], pc = 0)
    <>
    ((c == C_ON) ->
    ss(self_id(config), parent(config), S_ON).
    move_state(self_id(config), S_ON).
    RPC_Chamber_CLASS_BM(s = S_ON, phase = WhenPhase, cq = [], pc = 0)
    <>
    ss(self_id(config), parent(config), s).
    ignored_command(self_id(config), c).
    RPC_Chamber_CLASS_BM(pc = -1))))
    )
    )
   

    % END ACTION CLAUSES
    % ------------------

    % END STATE
    % =========
    
    ) +
    (
    % BEGIN GENERIC CLAUSES (shared by all states)
    % Whenever we are not sending a command to the children, a child may
    % spontaneously change its state due to a hardware event and send its
    % state upward. Such state-change messages are called notifications.

    % Notifications can occur in the following cases:
    %  (1) While in the action phase:
    %  (1.a) We have not received a command yet in this action phase.
    %  (1.b) We are executing an action, or we finished executing an action but still have to send
    %        some commands.

    % Note that this implies that we never receive notifications during the execution of the when phase (i) and
    % we never receive notifcations directly after we finish sending the last command after executing an action (ii).
    % The rationale behind this is as follows:
    %  (i)  The execution of the when clauses is a noninteractive process: the system decides what the
    %       new state is, based only on *local* information. Therefore, this process finishes almost instantly.
    %       In the real system, notifications which happen to arrive during the when phase would be queued, but
    %       we don't queue messages in our model. It is unlikely that any important behaviour is missed
    %       due to this design decision.
    %  (ii) After sending the last command, the model can move into the when phase. Moving to a new state
    %       before handling this notification will almost certainly be closer to the real behaviour of the
    %       system. We therefore disallow notifications at this point.

    % (1.a) We have initialized and we have not yet received a command in this action phase.
    % We now accept notifications.
    sum id:Id.(sum s1:State.(((isActPhase(phase)) && (is_child(id, children(config))) &&
                             (pc == 0)) ->
       rs(id, self_id(config), s1).
       move_phase(self_id(config), WhenPhase).
       RPC_Chamber_CLASS_BM(cs = cs[id -> s1], busy = removeFirst(busy, id), phase = WhenPhase, cq = [], pc = 0)))
    +

    % (1.b) We are in the middle of executing an action, or we finished executing and still have to send some
    % commands. We accept notifications, but we don't move to
    % the when phase, since we still must execute one or more statements. These semantics are valid
    % assuming a child does not send more than one notifications during the execution of the same
    % actions.
    sum id:Id.(sum s1:State.(((isActPhase(phase)) && (is_child(id, children(config))) &&
           ((pc > 0) ||
            ((pc == -1) && (cq != [])))) ->
       rs(id, self_id(config), s1).
       RPC_Chamber_CLASS_BM(cs = cs[id -> s1], busy = removeFirst(busy, id)))) +


    % Clause to send commands added by actions after the initialization phase. Note that
    % we don't keep track of the children which have not yet responded. Recepients are only
    % marked busy and not added to the nrf list.
    ((isActPhase(phase)) && (cq != [])) ->
        sc(self_id(config), child_id(head(cq)), command(head(cq))).
            RPC_Chamber_CLASS_BM(busy = insertUnique(busy, child_id(head(cq))),
                          cq = tail(cq)) +

    % Go to the when phase whenever all children are initialized, we executed an action
    % and there are no pending messages.
    ((isActPhase(phase)) && (cq == []) && (pc == -1)) ->
        move_phase(self_id(config), WhenPhase).
        RPC_Chamber_CLASS_BM(phase = WhenPhase, cq = [], pc = 0)

    % END GENERIC CLAUSES
    );

map processes: List(Id);
eqn processes = [3, 4, 5];
map c2s: Command -> State;
eqn c2s(C_STANDBY) = S_STANDBY;
    c2s(C_ON) = S_ON;
    c2s(C_OFF) = S_OFF;
init
    hide({ignored_command,
           queue_messages, enter_then_clause, enter_else_clause,
           skip_then_clause, start_initialization, end_initialization,
           noop_statement},
    allow({cs, cc, move_state, move_phase, ignored_command,
           queue_messages, enter_then_clause, enter_else_clause,
           skip_then_clause, start_initialization, end_initialization,
           noop_statement},
    comm({rs|ss -> cs, rc|sc -> cc},

grandParent(1, [3])
||
RPC_Wheel_CLASS(configuration(3, 1, [4, 5], allClassesEmpty[RPC_Sector_CLASS -> [4, 5]], false), S_OFF,allChildrenUninitialized[4 -> S_OFF][5 -> S_OFF], [], WhenPhase, [], 0)
||
RPC_Sector_CLASS(configuration(4, 3, [6, 7], allClassesEmpty[RPC_Chamber_CLASS -> [6, 7]], false), S_OFF,allChildrenUninitialized[6 -> S_OFF][7 -> S_OFF], [], WhenPhase, [], 0)
||
RPC_Sector_CLASS(configuration(5, 3, [8, 9], allClassesEmpty[RPC_Chamber_CLASS -> [8, 9]], false), S_OFF,allChildrenUninitialized[8 -> S_OFF][9 -> S_OFF], [], WhenPhase, [], 0)
||
RPC_Chamber_CLASS_BM(configuration(6, 4, [], allClassesEmpty, false), S_OFF,allChildrenUninitialized, [], WhenPhase, [], 0)
||
RPC_Chamber_CLASS_BM(configuration(7, 4, [], allClassesEmpty, false), S_OFF,allChildrenUninitialized, [], WhenPhase, [], 0)
||
RPC_Chamber_CLASS_BM(configuration(8, 5, [], allClassesEmpty, false), S_OFF,allChildrenUninitialized, [], WhenPhase, [], 0)
||
RPC_Chamber_CLASS_BM(configuration(9, 5, [], allClassesEmpty, false), S_OFF,allChildrenUninitialized, [], WhenPhase, [], 0)
    )
    )
    );